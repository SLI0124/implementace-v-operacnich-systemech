#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>

#include "gthr.h"

#include <bits/sigaction.h>
#include <bits/types/sigset_t.h>

#include "gthr_struct.h"

// function triggered periodically by timer (SIGALRM)
void gt_alarm_handle(int sig) {
	gt_schedule();
}

void gt_print_stats() {
	for (int i = 0; i < MaxGThreads; i++) {
		printf("thread %d hodnota rsp = %lx\n", i, gt_table[i].ctx.rsp);
	}
}

// initialize first thread as current context
void gt_init(void) {
	gt_current = &gt_table[0]; // initialize current thread with thread #0
	gt_current->state = Running; // set current to running
	signal(SIGALRM, gt_alarm_handle); // register SIGALRM, signal from timer generated by alarm
	signal(SIGINT, gt_print_stats);
}

// exit thread
void __attribute__((noreturn)) gt_return(int ret) {
	if (gt_current != &gt_table[0]) {
		// if not an initial thread,
		gt_current->state = Unused; // set current thread as unused
		free((void *) (gt_current->ctx.rsp + 16)); // free the stack
		gt_schedule(); // yield and make possible to switch to another thread
		assert(!"reachable");
		// this code should never be reachable ... (if yes, returning function on stack was corrupted)
	}
	while (gt_schedule()); // if initial thread, wait for other to terminate
	exit(ret);
}

// switch from one thread to other
bool gt_schedule(void) {
	struct gt *p;
	struct gt_context *old, *new;

	gt_reset_sig(SIGALRM); // reset signal

	p = gt_current;
	while (p->state != Ready) {
		// iterate through gt_table[] until we find new thread in state Ready
		if (++p == &gt_table[MaxGThreads]) // at the end rotate to the beginning
			p = &gt_table[0];
		if (p == gt_current) // did not find any other Ready threads
			return false;
	}

	if (gt_current->state != Unused) // switch current to Ready and new thread found in previous loop to Running
		gt_current->state = Ready;
	p->state = Running;
	old = &gt_current->ctx; // prepare pointers to context of current (will become old)
	new = &p->ctx; // and new to new thread found in previous loop
	gt_current = p; // switch current indicator to new thread
	gt_switch(old, new); // perform context switch (assembly in gtswtch.S)
	return true;
}

// return function for terminating thread
void gt_stop(void) {
	gt_return(0);
}

// create new thread by providing pointer to function that will act like "run" method
int gt_create(void (*f)(void)) {
	char *stack;
	struct gt *p;

	for (p = &gt_table[0];; p++) // find an empty slot
		if (p == &gt_table[MaxGThreads])
			// if we have reached the end, gt_table is full and we cannot create a new thread
			return -1;
		else if (p->state == Unused)
			break; // new slot was found

	stack = malloc(StackSize); // allocate memory for stack of newly created thread
	if (!stack)
		return -1;

	*(uint64_t *) &stack[StackSize - 8] = (uint64_t) gt_stop;
	//  put into the stack returning function gt_stop in case function calls return
	*(uint64_t *) &stack[StackSize - 16] = (uint64_t) f; //  put provided function as a main "run" function
	p->ctx.rsp = (uint64_t) &stack[StackSize - 16]; //  set stack pointer
	p->state = Ready; //  set state

	return 0;
}

// resets SIGALRM signal
void gt_reset_sig(int sig) {
	if (sig == SIGALRM) {
		alarm(0); // Clear pending alarms if any
	}

	sigset_t set; // Create signal set
	sigemptyset(&set); // Clear set
	sigaddset(&set, sig); // Set signal (we use SIGALRM)
	sigprocmask(SIG_UNBLOCK, &set, NULL); // Fetch and change the signal mask

	if (sig == SIGALRM) {
		ualarm(500, 500); // Schedule signal after given number of microseconds
	}
}

// uninterruptible sleep
int gt_uninterruptible_nanosleep(time_t sec, long nanosec) {
	struct timespec req;
	req.tv_sec = sec;
	req.tv_nsec = nanosec;

	do {
		if (0 != nanosleep(&req, &req)) {
			if (errno != EINTR)
				return -1;
		} else {
			break;
		}
	} while (req.tv_sec > 0 || req.tv_nsec > 0);
	return 0;
}
